---
title: 메모리
date: 2017-07-07 19:28:10
categories:
    - OS
---

컴퓨터의 저장공간은 역시 성능이 좋을 수록 비싸다. 때문에 메모리를 계층화시키고 이를 효율적으로 이용하기 위한 연구가 계속 되고 있다.

## 메모리의 계층 구조

>  캐시 메모리 - 메인메모리 - 디스크 스토리지

따라서 위와 같이 메모리를 계층화하여 용도에 맞게 사용한다.

## 메모리의 추상화

각 프로세스는 자신만의 `주소공간`(프로그램에 적재될 수 있는 추상화된 주소집합)을 갖는다.

> A 프로세스의 28번 주소
>
> B 프로세스의 28번 주소 

위 두 28번 주소는 달라야 한다.  

***따라서 논리주소만 고려할 수 있도록 조치***가 필요하다.

#### 재배치

- 동적 재배치 : 프로그램 실행시, MMU 통해 동적으로 배치

> but 덧셈을 매번 해야 하는 단점이 있다..

- 정적 재배치 : 적재한 초기 위치부터 주소 재배치(적재기 Loader 통해)

> 그러나...
>
> 1) 실수나 의도적으로 OS 파괴가 가능하다.
>
> 2) 여러 프로그램 동시에 실행이 어렵다.



## 가용메모리 공간 관리

실제 메모리보다 사용 메모리가 더 클 경우에 이것을 어떻게 대처할 것인가?

#### 스와핑

실행되지 않는 것, 디스크로 내림. 스왑 될때 재배치가 필요.

**어떤 메모리를 스와핑 할 것인가?** 리스트를 활용하여 가용메모리 공간을 관리한다.

1) 최초적합 : 빈공간 발견시 할당

2) 다음적합 : 지난번 위치의 다음부터 검색

3) 최적적합 : 모두 검색-> 가장 근접 공간에 할당 <-> 최악적합

4) 빠른적합 : 공통크기 메모리 공간 -> 서로 다른 리스트로 관리

> 그러나 스와핑은 너무 느리다.

#### 오버레이

프로세스를 작은 조각으로 나누어 실행한다.

> 그러나 그것은 프로그래머의 몫으로, 너무 복잡하다.

### 가상메모리

가용 메모리 공간을 종결할, 가상 메모리.

프로세스는 자신의 `고유한 주소공간`(프로그램에 적재될 수 있는 추상화된 주소집합)을 가지며, 주소공간은 `페이지`라는 조각으로 구성된다.

 `페이징 기법`을 활용하면, 여러 프로그램의 부분들이 `물리 메모리에 동시 존재`할 수 있다.

### 페이징 기법

어떻게 가상 메모리가 페이징 기법을 사용해서 매핑되는지 보자.

![img](http://i.imgur.com/tBTUlGH.png)

![img](http://i.imgur.com/eEKHY9D.png)

1. 프로그램이 메모리의 주소(가상메모리)를 참조한다.
2. 가상메모리는 `16bit 메모리` 는 `4bit/8bit`로 나누어 지는데, `4bit`로 `페이지테이블`을 검색한다.
3. 4bit `0 0 1 0` 은 10진수로 `2` 이므로 `페이지테이블` 2번과 매핑되고, 해당 페이지 테이블을 살펴보니 ` 1 1 0 1 ` 로 4번째 `1` 은 present/absent bit 이므로, 현재 메모리에 적재되어 있다는 것을 알 수 있다.
4. 페이지 테이블에서 찾은 `1 1 0 `과 8bit 메모리 주소 ` 0 0 0 0 0 1 0 0`을 합친 주소가 실제 물리 메모리 주소이다. MMU를 이용하여, 실제 물리 메모리 주소로 매핑된다.

> 만약 present bit가 0으로 매핑되어 있지 않으면, 페이지 폴트가 일어나고 페이지 프레임 내용이 교체 된다.

#### 페이지 테이블 구조

|캐싱가능여부|참조|수정|보호|present/absent|페이지 프레임 Num

#### 페이징 속도 향상

페이지 테이블 전체를 적재하여, 구현 비용이 커진다. TLB(Translation Lookaside Buffer)를 이용하여 페이지 테이블 참조없이 가상주소를 물리주소에 매핑한다. MMU 내부에 존재하며 순서 없이 한 번에 찾는다.

#### 페이지 교체 알고리즘

페이지 프레임 교체 대상은 누구인가?

1. 최적 페이지 교체 알고리즘(OPT) : 가장 먼 미래에 참조될 캐시 퇴출(그러나 미래를 알 수 없음;;)
2. LRU(Least Recently Used) : 시간상 최근 참조 -> 최근에 다시 참조
3. LFU(Least Frequently Used) : 빈도상 많이 참조 -> 미래에도 많이 참조(maxheap으로 구현)
4. FIFO(First-In First-Out) : 먼저 들어온게 먼저 나감.
5. Second-Chance 페이지 교체 알고리즘, 클록 페이지 교체 알고리즘

![img](http://i.imgur.com/8BXWsCu.png)

대상인지 아닌지 확인할 때 R=1 이면, 0으로 바꾸고 넘어감. R이 0이라면 대상.

6. 작업집합 페이지 교체 알고리즘 : 프로세스가 현재 자주 참조하는 페이지들의 집합인지 확인. 문맥교환시 - 선페이징 통해 프로세스 시작전 작업집합들 페이지 적재.



#### 페이지 교체시 쟁점

지역 페이지 교체 : 자기 프로세스에 속해있는 페이지중 고려.

전역 페이지 교체 : 전체 프로세스 중에 고려, 실행에 따라 작업집합의 크기 변할 때 유리.

혼합 : 전역 알고리즘 사용, 크기에 비례하여 페이지 할당. 페이지 폴트 빈도수(PFF)에 맞추어 추가 할당/반납 -> 상한/하한

페이지 크게 : 페이지 폴트 적게 일어남, 관리 쉽다, 페이지 테이블 작아짐, but 내부 단편화 심함.

페이지 작게 : 내부 단편화 줄어듬, But 많은 페이지 필요



## Reference

운영체제론 - 노삼혁