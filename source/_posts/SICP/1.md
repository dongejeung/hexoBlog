---
title: 1
date: 2020-01-28 16:18:10
categories:
    - SICP
---

<pre>

책을 읽으면서 연습문제를 풀겠다.
코드관리는 알면 하고 모르면,
그냥 실행기에서 돌려보고,
텍스트라도 저장하겠다.

Lisp의 방언을 사용하는데,
Lisp은 재귀방정식을 컴퓨터 계산 모형으로 사용할 수 있는지 
살펴보고자 1950년대에 존 메카시가 만든 언어라고 한다.
대수식의 미분식이나 적분식을 구하는 것처럼,
기호로 이루어진 데이터를 다루기에 알맞게 설계되었다고 한다.

데이터와 프로시저를 엄격하게 구분 짓지 않는다고 한다.

=====

1.1 프로그램 짤 때 바탕이 되는 것.
- 기본식
- 엮어내는 수단 => 간단한 것을 모아 복잡한 것을 만듬.
- 요약하는 수단 => 복잡한 것에 이름을 붙여 하나로 다룰 수 있게끔 간추린다.

// 기본 연산식 + 짜여진 식 + 변수나 함수로 이름붙여 재사용.

=====

앞가지 쓰기 함. 연산자가 최왼쪽 괄호로 블락처리 함.
ex) (+ 1 2 3)

식 속에 식 넣기 쉬움.
ex)(+ (+ 1 2) (- 5 4))

- 인간이 보기 쉽게 들여쓰기 함. 

- 변수 작성시 define 씀.
ex) (define a 1)

/*
    scheme은 인터프리터 언어임.
    여기서 사용하는 프로시저라는 용어는 함수 정도로 해석하면 되려나
*/

- 변수를 저장하는 공간 => 메모리, 환경.

=======

엮은 식 계산방법.

1. 엮은식에서 부분 식의 값을 모두 구한다.
2. 엮은식에서 맨 왼쪽에 있는 식(연산자)의 값은 프로시저가 되고,
나머지 식(피연산자)의 값은 인자가 된다.
프로시저를 인자에 적용하여 엮은식의 값을 구한다.

/*
    여기서 처음부터 되도는(recursive 재귀)라는 용어가 나오는데
    존나 헷갈린다.
    엮은식을 계산하려면 부분식을 계산행랴 하고,
    부분식을 계산할 때에도 같은 프로세스를 따른다.
    이걸 재귀라고 한다는데..
    앞가지 쓰기 방식에서 앞에 있는 연산자로 다시 돌아온다는 뜻인가

    같은 절차를 여러 번 되밟는 기법 => 재귀(recursive)
    이것이 문자 그대로의 정의인 것 같긴 한데
    어쨌든 재귀에 익숙해질 필요가 있다.
*/

// 여기서 엮은 식의 계수는 연사자의 수로 나타나나 싶다.

// 그리고 context(문맥)라는 개념은 js 공부하면서 배웠는데 통용되는 용어인 듯 하다.

// define은 연산자가 아니고 변수 정의라고 한다.
 이처럼 게산 규칙이 따로 밝혀져 있는 것을 특별한 형태라고 한단다.

========

!@프로시저 정의하기.
ex)
(define (square x) (* x x))
=> (define (<name> <formal parameters>) <body>)
// 일반식(?)으로 표현함.

사각형의 넓이 구하는 식을 짜는 것이 나온다.
(define (sum-of-squares x y)
        (+ (square x) (square y)))

// 요런식으로 프로시저를 짠다는 듯.

=======

맞바꿈 계산법.

- 묶음 프로시저를 인자에 맞춘다는 것은, 프로시저의 몸 속에 있는 모든 인자이름(formal parameter)을
 저마다 그에 대응하는 인자 값으로 맞바꾼 다음,
 그렇게 얻어낸 식의 값을 구하는 것.

 => 최소 인수를 계산해서 점점 계산식을 타고 올라감.

 // 실제 프로시저가 동작하는 방식은 갇힌 환경(local enviroment) 에 인자 이름을 넣어놓고 계산한다고 한다.

 =======

 인자 먼저 계산법과 정의대로 계산법.

 => 인자 값을 계산하지 않고, 식 자체를 인자 이름과 맞바꾸어 가다가
  마지막에 기본 연산으로만 이루어진 식을 얻을 때 그 식의 값을 구하는 방법.

// 전개를 먼저 쫙 다 해놓는다고 봐야하나? 뭐 그럼.
샘플 코드들을 참조. p.22
요런 방식의 차이에 따라 연산의 횟수, 계산값이 다르게 나올 수 있다.

=======

조건식과 술어(predicate)

cond(conditional) : 조건문이다.
ex)

(define (abs x)
    (cond   ((< x 0) x)
            ((= x 0) 0)
            ((< x 0) -x)))

일반식 =>            
(cond   (<p1> <e1>)
        (<p2> <e2>)
        (<p3> <e3>))

=> 요건 술어 p의 값을 구하고, 조건과 비교 다음술어로 넘어가거나
 쌍에 맞는 결과식(consequent expression)을 구함.

// 아 투자전략 구상을 위해 예전에 봤던 파생상품론 책을 사고 싶은데..
 영어라 제목이 뭐라고 검색 때려야되지..
 뭔 options futures 이딴거 들어간 책이었는데,
 예전에 현금벌려고 중고로 팔았었다..
 괘니 팔았나;;
 책을 하도 이것저것 사고 팔다 보니..

=======



















</pre>

## Reference
# SICP 